"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recordKey = exports.tid = exports.language = exports.cid = exports.nsid = exports.atIdentifier = exports.handle = exports.did = exports.atUri = exports.uri = exports.datetime = void 0;
const iso_datestring_validator_1 = require("iso-datestring-validator");
const cid_1 = require("multiformats/cid");
const types_1 = require("../types");
const syntax_1 = require("@atproto/syntax");
const common_web_1 = require("@atproto/common-web");
function datetime(path, value) {
    try {
        if (!(0, iso_datestring_validator_1.isValidISODateString)(value)) {
            throw new Error();
        }
    }
    catch {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`),
        };
    }
    return { success: true, value };
}
exports.datetime = datetime;
function uri(path, value) {
    const isUri = value.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null;
    if (!isUri) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a uri`),
        };
    }
    return { success: true, value };
}
exports.uri = uri;
function atUri(path, value) {
    try {
        (0, syntax_1.ensureValidAtUri)(value);
    }
    catch {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid at-uri`),
        };
    }
    return { success: true, value };
}
exports.atUri = atUri;
function did(path, value) {
    try {
        (0, syntax_1.ensureValidDid)(value);
    }
    catch {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid did`),
        };
    }
    return { success: true, value };
}
exports.did = did;
function handle(path, value) {
    try {
        (0, syntax_1.ensureValidHandle)(value);
    }
    catch {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid handle`),
        };
    }
    return { success: true, value };
}
exports.handle = handle;
function atIdentifier(path, value) {
    const isDid = did(path, value);
    if (!isDid.success) {
        const isHandle = handle(path, value);
        if (!isHandle.success) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be a valid did or a handle`),
            };
        }
    }
    return { success: true, value };
}
exports.atIdentifier = atIdentifier;
function nsid(path, value) {
    try {
        (0, syntax_1.ensureValidNsid)(value);
    }
    catch {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid nsid`),
        };
    }
    return { success: true, value };
}
exports.nsid = nsid;
function cid(path, value) {
    try {
        cid_1.CID.parse(value);
    }
    catch {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a cid string`),
        };
    }
    return { success: true, value };
}
exports.cid = cid;
// The language format validates well-formed BCP 47 language tags: https://www.rfc-editor.org/info/bcp47
function language(path, value) {
    if ((0, common_web_1.validateLanguage)(value)) {
        return { success: true, value };
    }
    return {
        success: false,
        error: new types_1.ValidationError(`${path} must be a well-formed BCP 47 language tag`),
    };
}
exports.language = language;
function tid(path, value) {
    try {
        (0, syntax_1.ensureValidTid)(value);
    }
    catch {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid TID (timestamp identifier)`),
        };
    }
    return { success: true, value };
}
exports.tid = tid;
function recordKey(path, value) {
    try {
        (0, syntax_1.ensureValidRecordKey)(value);
    }
    catch {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid Record Key`),
        };
    }
    return { success: true, value };
}
exports.recordKey = recordKey;
//# sourceMappingURL=formats.js.map